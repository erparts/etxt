# The panorama for Ebitengine font rendering

There are two main approaches when it comes to fonts in Ebitengine games:
- Use vectorial fonts, either with [`ebiten/text`](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/text) or [`etxt`](https://pkg.go.dev/github.com/tinne26/etxt). This is the main way to do text rendering.
- If you are making a pure pixel art game, you may consider using bitmaps (pixel art fonts rendered for one or more specific sizes). Sadly, you will have to roll your own code as I don't think any good package for Ebitengine exists yet. The rest of this document doesn't really deal with bitmap fonts, only vectorial fonts.

Now I would start writing a FAQ for common problems with text rendering... but there are basically only two common issues:
- **"I don't understand font.Face, DPI, origin position...**: this part refers to the technical properties, concepts and implementation of font renderers. Some people don't care about this and can make fonts work anyway. That's ok. But if you care about it and want to know what you are doing, I have three pieces of advice:
	1. Read [FreeType glyph conventions](https://freetype.org/freetype2/docs/glyphs/index.html) up to section IV or V. This is a *must read* for any developer trying to work with fonts on anything even half serious. It's excellently written, clear, concise and touches all the critical topics. You won't find a shorter and better reference.
	2. Ebitengine's `ebiten/text` package does not explain typography concepts. If you want to learn more about fonts and understand what you are doing, switch to `etxt`. You can switch back later when you know more, but `etxt` has great documentation that will help you learn a lot if you are getting started.
	3. If you are still struggling with practical implementation, both Ebitengine and `etxt` have many examples. Look for them, read the code, execute them and learn. If there's something you don't understand, go back to FreeType glyph conventions or drop by Ebitengine's discord chat and ask for help.
- **"My text looks bad, blurry, ugly, sad"**: ok, there are two parts to this...
	- The first is that *you need to understand with utmost clarity* how what you draw on Ebitengine ends up being projected to a physical monitor. For this, Ebitengine's `Layout()` method is key. If you are confused about how `Layout()` works, read this [document that explains it in more detail](https://github.com/tinne26/kage-desk/blob/main/docs/tutorials/ebitengine_game.md#layout). There's no point in continuing reading here until you understand those concepts.
	- The second is that even when you understand the previous point and are doing text scaling properly and using the full resolution of your window (and this is shown both on Ebitengine and `etxt` examples, so refer to those if you are still struggling), some rendering differences will still exist. They are detailed over the next section.


## Limitations and differences between text renderers

Both `ebiten/text` and `etxt` use Golang's [`x/image/font/sfnt`](https://pkg.go.dev/golang.org/x/image/font/sfnt) font library under the hood. This means we don't use the system's native stack or a top-tier font library. This means there are some limitations in text rendering that can make your text in Ebitengine games look different from other applications.

Now, differences in text rendering between applications are a thing even outside Ebitengine. Browsers have been known to render text differently to each other for a long time. The goal of this section is not to help you make Ebitengine applications render text exactly like VSCode, Firefox, or any other specific application (as we all use different tech stacks under the hood), but rather to list limitations and enumerate some of the factors that may make results look different between renderers, as well as sharing some tips about what can be done about each one.

Let's start with the most painful limitations:
- We have no support for complex scripts (e.g. arabic, devanagari, etc). This is the single biggest hole in text rendering in Ebitengine, and *it's a big deal*. You can find more context about the general problem of text shaping [in this document](https://github.com/tinne26/etxt/blob/main/docs/shaping.md). I've discussed this with Hajime Hoshi a few times, and we all acknowledge that it's an important problem and are interested in improving the situation, but there's no clean and easy way to solve it. Any solution will have a significant impact on the APIs of current Ebitengine text rendering packages.
- Multiple limitations of the `x/image/font/sfnt` implementation. All these could be improved by moving [golang/go#45325](https://github.com/golang/go/issues/45325) forward:
	- No support for embedded bitmaps within sfnt fonts ([SBIX table](https://learn.microsoft.com/en-us/typography/opentype/otspec183/sbix)). While this would be nice to have, it's not a big deal for videogames either. If you need to stick to bitmaps in a pixel game and you don't like the results you are getting with regular text rendering packages[^1], consider just going with bitmaps right away.
	- No support for hinting. This is relevant for very small glyphs, but if you need that in a game you may be better using bitmap fonts directly. Having zoomable text in Ebitengine games would be rather unusual, so this isn't a prioritary issue. It's probably too much effort compared to what it adds in terms of rendering quality for most cases.
	- No support for colored glyphs. This includes emojis and others. I personally do not care much about this.
	- No support for variable weight fonts. I honestly don't care about this, it's a flashy feature but not very relevant in practice, at least for the kind of videogames we most often make with Ebitengine.
	- Technically, the lack of support for complex scripts is also due to `sfnt` limitations, and we could improve the situation without necessarily importing HarfBuzz as a whole if the relevant font tables were exposed.

[^1]: One important trick to keep in mind is that since expected DPIs may vary for fonts and platforms (e.g. 72DPI vs 96DPI), sometimes changing the DPI (in `ebiten/text`) or multiplying font sizes by `4/3` or `3/4` may help you get sharper results. In the end, if you are taking `ebiten.DeviceScaleFactor()` into account, the results may still not be ideal for some fonts and systems with fractional scaling... but it can still help in many cases.

Other differences and less significant limitations:
- We have no readily available subpixel-antialiasing. This can be implemented in `etxt` with a custom rasterizer + shader, and I'll probably do it someday, but we don't have it yet.
- Gamma correction. Neither `ebiten/text` nor `etxt` apply gamma correction when rendering glyphs. This means that when compared to other renderers, the glyphs may look thinner in Ebitengine. This is not a big deal though, as gamma correction can be implemented in `etxt` in multiple ways if desired and it's relatively easy to do.
- `x/image/font` and `x/image/font/sfnt` have some subtle bugs and other oddities, like broken kerning scaling, incorrect application of `font.Hinting` in some cases (which is not even actual font hinting but glyph quantization) and a few more things like that. Everything I could find was possible to fix directly on `etxt`, but those issues remain in `ebiten/text`. Nothing is major enough to be obviously visible, though, so don't worry too much about it.
- Limited font [quantization](https://github.com/tinne26/etxt/blob/main/docs/quantization.md) configuration. In the past, Ebitengine used to quantize or align the glyphs to the pixel grid, without properly respecting the `font.Hinting` property (which is not actually hinting, as mentioned in the previous point). In v2.5.0, Ebitengine is switching to 1/4 pixel quantization. On `etxt`'s side, as of v0.0.8, only full quantization or no quantization at all are allowed, but often you would like a different compromise. The main branch of `etxt` has an improved implementation, but that won't be released with a tagged version until some unspecified time in the future, so... for the moment, the average user doesn't have access to fully configurable font quantization.
- Outlining, underlining, strikethrough and other practical features are not readily available with high quality anywhere (low quality versions are quite easy to achieve). They could be implemented in `etxt` by anyone interested enough in them, but they are not trivial.
- No out-of-the-box support for rich text, specially combining multiple fonts. `etxt` has decent primitives for building that, and I may work on something that covers most basic needs in the future, but in general games can have pretty unique needs, so we are unlikely to create something too complex and exhaustive.

